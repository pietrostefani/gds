{
  "hash": "33589d88adb0ec1840fb940193694aa4",
  "result": {
    "markdown": "---\nformat:\n  html:\n    code-fold: false\n---\n\n# Lab in Python {#sec-spatial-data-Python .unnumbered}\n\nIn this lab, we will learn how to load, manipulate and visualize spatial data. In some senses, spatial data are usually included simply as \"one more column\" in a table. However, *spatial is special* sometimes and there are few aspects in which geographic data differ from standard numerical tables. In this session, we will extend the skills developed in the previous one about non-spatial data, and combine them. In the process, we will discover that, although with some particularities, dealing with spatial data in `Python` largely resembles dealing with non-spatial data.\n\n## Installing libraries\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Import the pandas library, which is useful for data manipulation and analysis.\nimport pandas as pd\n# Import the geopandas library, which extends pandas to support spatial data operations.\nimport geopandas as gpd\n# Import the Point class from the shapely.geometry module, used for handling geometric points.\nfrom shapely.geometry import Point\n# Import the osmnx library, which simplifies the process of downloading and analyzing street networks and other geospatial data from OpenStreetMap.\nimport osmnx as ox\n# Import the contextily library, which is used for adding basemaps (like raster tiles) to geospatial plots.\nimport contextily as cx\n# Import the pyplot module from matplotlib, a library for creating static, animated, and interactive visualizations in Python.\nimport matplotlib.pyplot as plt\n# Import the CRS class from pyproj, which provides tools for defining and transforming coordinate reference systems.\nfrom pyproj import CRS\n# Operating systems\nimport os\n```\n:::\n\n\n## Datasets\n\nToday we are going to go to London. We will be playing around with different datasets loading them both locally and dynamically from the web. You can download data manually, keep a copy on your computer, and load them from there.\n\n### Creating geographic data\n\nFirst we will use the following commands create geographic datasets *from scratch* representing coordinates of some famous locations in London. Most projects start with pre-generated data, but it's useful to create datasets to understand data structures.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Create the DataFrame\ndata = {\n    'name': [\"The British Museum\", \"Big Ben\", \"King's Cross\", \"The Natural History Museum\"],\n    'lon': [-0.1459604, -0.1272057, -0.1319481, -0.173734],\n    'lat': [51.5045975, 51.5007325, 51.5301701, 51.4938451]\n}\npoi_df = pd.DataFrame(data)\n\n# Convert DataFrame to GeoDataFrame\ngeometry = [Point(xy) for xy in zip(poi_df['lon'], poi_df['lat'])]\npoi_gdf = gpd.GeoDataFrame(poi_df, geometry=geometry)\n\n# Set the coordinate reference system (CRS)\npoi_gdf.set_crs(epsg=4326, inplace=True)\n\nprint(poi_gdf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                         name       lon        lat                   geometry\n0          The British Museum -0.145960  51.504598  POINT (-0.14596 51.50460)\n1                     Big Ben -0.127206  51.500732  POINT (-0.12721 51.50073)\n2                King's Cross -0.131948  51.530170  POINT (-0.13195 51.53017)\n3  The Natural History Museum -0.173734  51.493845  POINT (-0.17373 51.49385)\n```\n:::\n:::\n\n\n### Types of Data\n\nNow let's look at the different types of geographical data starting with polygons. We will use a dataset that contains the boundaries of the districts of London. We can read it into an object named districts.\n\n::: {.panel-tabset group=\"data\"}\n\n## Polygons\n\nWe first import the district shapefile use `gpd.read_file`, we then plot it to make sure we are seeing it 'correctly'. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Read the shapefile for districts\ndistricts = gpd.read_file(\"data/London/Polygons/districts.shp\")\n\n# Create a simple plot\ndistricts.plot()\n\n# Display the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-4-output-1.png){width=558 height=411}\n:::\n:::\n\n\n## Lines\n\nWe them import a file of roads in London and plot it.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Read the shapefile for A roads\na_roads = gpd.read_file(\"data/London/Lines/a_roads.shp\")\n\n# If you needed to import a `geojson` file, this would be the function:\n# a_roads = gpd.read_file(\"data/London/Lines/a_roads.geojson\")\n\n# Create a simple plot of the roads\na_roads.plot()\n\n# Display the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-5-output-1.png){width=562 height=411}\n:::\n:::\n\n\n## Points\n\nWe can also import point files. So far, we have imported `shapefiles` and `geojsons`, but we can also obtain data from urls like in the [Open Science DIY](https://pietrostefani.github.io/gds/openscienceDIY.html) session or from other sources like **OpenStreetMap**. Both `R` and `Python` have libraries that allow us to query OpenStreetMap.\n\nNote that we use the method `features_from_place`, which queries for points in a particular place (London in this case) and creates a GeoDataFrame of OSM features.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Create an OSM query for \"Greater London, U.K.\"\nquery = \"London, United Kingdom\"\nrestaurants = ox.features_from_place(query, tags={\"amenity\": [\"restaurant\", \"bar\", \"pub\"]})\n# Create a simple plot of the roads\nrestaurants.plot()\n# Display the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-6-output-1.png){width=531 height=414}\n:::\n:::\n\n\nAnd to inspect the data queried:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nrestaurants.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'geopandas.geodataframe.GeoDataFrame'>\nMultiIndex: 12197 entries, ('node', 451152) to ('relation', 17299869)\nColumns: 572 entries, addr:city to ways\ndtypes: geometry(1), object(571)\nmemory usage: 53.6+ MB\n```\n:::\n:::\n\n\nYou do not need to know at this point what happens behind the scenes when we run these lines but, if you are curious, we are making a query to OpenStreetMap (almost as if you typed \"restaurant in London, UK\" within Google Maps) and getting the response as a table of data, instead of as a website with an interactive map. Pretty cool, huh?\n\n*Note*: the code cells above requires internet connectivity. For more about querying from osm see [here](https://osmnx.readthedocs.io/en/stable/user-reference.html#osmnx.features.features_from_point).\n\n**Important**: Be careful, if you query too much data, your environment is likely to get stuck.\n:::\n\n## Inspecting Spatial Data\n\n### Inspecting\n\nJust like a `dataframe` (see the OpenScience Lab), we can inspect the data (attributes table) within a spatial object. The most direct way to get from a file to a quick visualization of the data is by loading it and calling the `plot` command. Let's start by inspecting the data like we did for non spatial `dataframes`.\n\nWe can see our data is very similar to a traditional, non-spatial `dataFrame`, but with an additional column called geometry.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Read the first 5 rows of the data\nprint(districts.head()) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  DIST_CODE             DIST_NAME  \\\n0      00AA        City of London   \n1      00AB  Barking and Dagenham   \n2      00AC                Barnet   \n3      00AD                Bexley   \n4      00AE                 Brent   \n\n                                            geometry  \n0  POLYGON ((531028.507 181611.160, 531036.062 18...  \n1  POLYGON ((550817.007 184195.999, 550814.000 18...  \n2  POLYGON ((526830.313 187535.453, 526830.302 18...  \n3  POLYGON ((552373.534 174606.900, 552372.893 17...  \n4  POLYGON ((524661.688 184631.047, 524665.261 18...  \n```\n:::\n:::\n\n\nWe can inspect the object in different ways :\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Read the first row\nprint(districts.iloc[0])\n\n# Read the first column\nprint(districts.iloc[:, 0])\n\n# Read the first row, first column\nprint(districts.iloc[0, 0])\n\n# Read the column \"DIST_NAME\"\nprint(districts['DIST_NAME'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDIST_CODE                                                 00AA\nDIST_NAME                                       City of London\ngeometry     POLYGON ((531028.5069610038 181611.15961117705...\nName: 0, dtype: object\n0     00AA\n1     00AB\n2     00AC\n3     00AD\n4     00AE\n5     00AF\n6     00AG\n7     00AH\n8     00AJ\n9     00AK\n10    00AL\n11    00AM\n12    00AN\n13    00AP\n14    00AQ\n15    00AR\n16    00AS\n17    00AT\n18    00AU\n19    00AW\n20    00AX\n21    00AY\n22    00AZ\n23    00BA\n24    00BB\n25    00BC\n26    00BD\n27    00BE\n28    00BF\n29    00BG\n30    00BH\n31    00BJ\n32    00BK\nName: DIST_CODE, dtype: object\n00AA\n0             City of London\n1       Barking and Dagenham\n2                     Barnet\n3                     Bexley\n4                      Brent\n5                    Bromley\n6                     Camden\n7                    Croydon\n8                     Ealing\n9                    Enfield\n10                 Greenwich\n11                   Hackney\n12    Hammersmith and Fulham\n13                  Haringey\n14                    Harrow\n15                  Havering\n16                Hillingdon\n17                  Hounslow\n18                 Islington\n19    Kensington and Chelsea\n20      Kingston upon Thames\n21                   Lambeth\n22                  Lewisham\n23                    Merton\n24                    Newham\n25                 Redbridge\n26      Richmond upon Thames\n27                 Southwark\n28                    Sutton\n29             Tower Hamlets\n30            Waltham Forest\n31                Wandsworth\n32               Westminster\nName: DIST_NAME, dtype: object\n```\n:::\n:::\n\n\nWe can read or create subsets:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# dataframe can be subsetted using conditional statement\n# read the rows which have \"City of London\" as value for DIST_NAME\n# Filter rows where 'DIST_NAME' is 'City of London'\nfiltered_districts = districts[districts['DIST_NAME'] == 'City of London']\n\nprint(filtered_districts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  DIST_CODE       DIST_NAME                                           geometry\n0      00AA  City of London  POLYGON ((531028.507 181611.160, 531036.062 18...\n```\n:::\n:::\n\n\n### Quick visualisation\n\nLet's start by plotting London in a colour and adding Hackney (a district) in a different colour.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Plot London in grey\nfig, ax = plt.subplots()\ndistricts.plot(ax=ax, color='lightgrey')\n\n# Add city of London (Hackney) in turquoise to the map\nhackney = districts[districts['DIST_NAME'] == 'Hackney']\nhackney.plot(ax=ax, color='turquoise')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-11-output-1.png){width=558 height=411}\n:::\n:::\n\n\nSome guidance on colours in `Python` can be found [here](https://matplotlib.org/stable/gallery/color/named_colors.html).\n\n\n## Styling plots\n\nIt is possible to tweak many aspects of a plot to customize if to particular needs. In this section, we will explore some of the basic elements that will allow us to obtain more compelling maps.\n\n**Note**: some of these variations are very straightforward while others are more intricate and require tinkering with the internal parts of a plot. They are not necessarily organized by increasing level of complexity.\n\n### Plotting different layers\n\nWe first start by plotting one layer over another\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Plotting the geometries\nfig, ax = plt.subplots()\n\n# Plot districts with no fill (transparent fill)\ndistricts.plot(ax=ax, edgecolor='black', facecolor='none')  # No fill, only border\n# Plot roads with transparency\na_roads.plot(ax=ax, color='brown')  # Roads in brown\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-12-output-1.png){width=558 height=411}\n:::\n:::\n\n\n### Changing transparency\n\nThe intensity of color of a polygon can be easily changed through the alpha attribute in plot. This is specified as a value betwee zero and one, where the former is entirely transparent while the latter is the fully opaque (maximum intensity):\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Plotting the geometries\nfig, ax = plt.subplots()\n\n# Plot districts with no fill (transparent fill)\ndistricts.plot(ax=ax, edgecolor='black', facecolor='none')  # No fill, only border\n# Plot roads with transparency\na_roads.plot(ax=ax, color='brown', alpha=0.5)  # Roads in brown\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-13-output-1.png){width=558 height=411}\n:::\n:::\n\n\n### Removing axes\n\nAlthough in some cases, the axes can be useful to obtain context, most of the times maps look and feel better without them. Removing the axes involves wrapping the plot into a figure, which takes a few more lines of aparently useless code but that, in time, it will allow you to tweak the map further and to create much more flexible designs.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Plotting the geometries\nfig, ax = plt.subplots()\n\n# Plot districts with no fill (transparent fill)\ndistricts.plot(ax=ax, edgecolor='black', facecolor='none')  # No fill, only border\n# Plot roads with transparency\na_roads.plot(ax=ax, color='brown', alpha=0.5)  # Roads with 50% transparency\n\n# Remove the axis\nax.axis('off')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-14-output-1.png){width=498 height=389}\n:::\n:::\n\n\nLet us stop for a second a study each of the previous lines:\n\nWe have first created a figure named `fig` with one axis named `ax` by using the command `plt.subplots` (part of the library matplotlib, which we have imported at the top of the notebook). Note how the method is returning two elements and we can assign each of them to objects with different name (`fig` and `ax`) by simply listing them at the front of the line, separated by commas.\n\nSecond, we plot the geographies as before, but this time we tell the function that we want it to draw the polygons on the axis we are passing, `ax`. This method returns the axis with the geographies in them, so we make sure to store it on an object with the same name, `ax`.\n\nOn the third line, we effectively remove the box with coordinates.\n\nFinally, we draw the entire plot by calling plt.`show()`.\n\n### Adding a title\n\nAdding a title is an extra line, if we are creating the plot within a figure, as we just did. To include text on top of the figure:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Plotting the geometries\nfig, ax = plt.subplots()\n\n# Plot districts with no fill (transparent fill)\ndistricts.plot(ax=ax, edgecolor='black', facecolor='none')  # No fill, only border\n# Plot roads with transparency\na_roads.plot(ax=ax, color='brown', alpha=0.5)  # Roads with 50% transparency\n# Remove the axis\nax.axis('off')\n# Add figure title\nfig.suptitle(\"Main roads in London\")\n# Display\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-15-output-1.png){width=498 height=437}\n:::\n:::\n\n\n### Changing what border lines look like\n\nBorder lines sometimes can distort or impede proper interpretation of a map. In those cases, it is useful to know how they can be modified. Let us first see the code to make the lines thicker and black, and then we will work our way through the different steps:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# Convert CRS from WGS 84 (EPSG:4326) to British National Grid (EPSG:27700)\npoi_gdf_bng = poi_gdf.to_crs(epsg=27700)\n\n# Plotting the geometries\nfig, ax = plt.subplots()\n# Plot districts with no fill, black borders\ndistricts.plot(ax=ax, edgecolor='black', facecolor='none')\n# Plot roads with brown color and 50% transparency\na_roads.plot(ax=ax, color='brown', alpha=0.5)\n# Plot restaurants with blue color and adjusted size\npoi_gdf_bng.plot(ax=ax, edgecolor='blue', facecolor='blue', markersize=100)# Adjust size accordingly\n# Remove the axis for a clean look\nax.axis('off')\n# Add figure title\nfig.suptitle(\"Main roads in London\")\n# Display the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-16-output-1.png){width=498 height=437}\n:::\n:::\n\n\n### Labelling\n\nLabeling maps is of paramount importance as it is often key when presenting data analysis and visualization. Properly labeled maps enables readers to effectively analyze and interpret spatial data.\n\n- `iterrows()` is a pandas function that iterates over DataFrame rows as (index, Series) pairs. Here, `idx` is the index of the row, and row is a `pandas` series containing the data for that particular district.\n- `centroid = row['geometry'].centroid` gets the centroid of each district's geometry. \n`row['geometry']` refers to the geometry of the district, which could be a polygon or a multipolygon. `.centroid` computes the geometric center (centroid) of this polygon. \n- `ax.text()` is a method from `Matplotlib`, used to place text at specific coordinates on the plot. `centroid.x` and `centroid.y` provide the x and y coordinates of the centroid, which determine where the text will be placed. `row['DIST_NAME']` is the name of the district that will be displayed as the label. `fontsize=6` sets the size of the text to 8 points. `ha='center'` ensures that the text is horizontally aligned to the center of the specified coordinates.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Plot the districts with a gray fill\nfig, ax = plt.subplots()\ndistricts.plot(ax=ax, edgecolor=\"black\", facecolor='none')\n\n# Add text labels at the centroids of the districts\nfor idx, row in districts.iterrows():\n    centroid = row['geometry'].centroid\n    ax.text(centroid.x, centroid.y, row['DIST_NAME'], fontsize=6, ha='center')\n\n# Remove axis\nax.set_axis_off()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-17-output-1.png){width=498 height=389}\n:::\n:::\n\n\n## Coordinate reference Systems\n\n### CRSs in Python\n\nCoordindate reference systems (CRS) are the way geographers and cartographers represent a three-dimentional objects, such as the round earth, on a two-dimensional plane, such as a piece of paper or a computer screen. If the source data contain information on the CRS of the data, we can modify this.\n\nFirst we need to retrieve the CRS from the vector data.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Retrieve the CRS from the GeoDataFrame\ncrs = districts.crs\n# Print the CRS information\nprint(crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEPSG:27700\n```\n:::\n:::\n\n\nWe can also retrieve some additional information about the used CRS. For example, try to run:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Check if the CRS is geographic or not\nis_geographic = CRS(crs).is_geographic\n# Find out the CRS units\nunits_gdal = CRS(crs).axis_info[0].unit_name if CRS(crs).axis_info else None\n# Extract the SRID\nsrid = CRS(crs).to_epsg()\n# Extract the proj4string representation\nproj4string = CRS(crs).to_proj4()\n\n# Print results\nprint(f\"Is Geographic: {is_geographic}\")\nprint(f\"Units (GDAL): {units_gdal}\")\nprint(f\"SRID: {srid}\")\nprint(f\"Proj4 String: {proj4string}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs Geographic: False\nUnits (GDAL): metre\nSRID: 27700\nProj4 String: +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs +type=crs\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/pietrost/.virtualenvs/r-reticulate/lib/python3.9/site-packages/pyproj/crs/crs.py:1293: UserWarning: You will likely lose important projection information when converting to a PROJ string from another format. See: https://proj.org/faq.html#what-is-the-best-format-for-describing-coordinate-reference-systems\n  proj = self._crs.to_proj4(version=version)\n```\n:::\n:::\n\n\nAs we can see, there is information stored about the reference system: it is using the standard British projection (British National Grid EPSG:27700), which is expressed in meters. There are also other less decipherable parameters but we do not need to worry about them right now.\n\nIf we want to modify this and \"reproject\" the polygons into a different CRS, the quickest way is to find the EPSG code online (epsg.io is a good one, although there are others too). For example, if we wanted to transform the dataset into lat/lon coordinates, we would use its EPSG code, 4326 (CRS's name \"WGS84\"):\n\nIn cases when a coordinate reference system (CRS) is missing or the wrong CRS is set, the `.to_crs` function can be used:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Transform the CRS to EPSG:4326\ndistricts_4326 = districts.to_crs(epsg=4326)\n\n# Optionally, print the new CRS to verify\nprint(districts_4326.crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEPSG:4326\n```\n:::\n:::\n\n\n### From coordinates to spatial objects\n\nCRSs are also very useful if we obtain data that is in a csv, has coordinates but needs to be transformed to a `GeoDataFrame`. For example we have some London housing transactions we want to import and use.\n\nWe want to transform the .csv in a `GeoDataFrame` using the coordinates stored in columns 17 and 18, and then we set the `GeoDataFrame` CRS to the British National Grid (EPSG:27700).\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Import housesales data from CSV\nhousesales = pd.read_csv(\"data/London/Tables/housesales.csv\")\n\n# Filter housesales to include only those with price less than 500000\nhousesales_f = housesales[housesales['price'] < 500000]\n\n# Assume columns 17 and 18 are 'longitude' and 'latitude' respectively\nhousesales_gdf = gpd.GeoDataFrame(\n    housesales_f, geometry=gpd.points_from_xy(housesales_f.greastings, housesales_f.grnorthing), crs=\"EPSG:27700\"\n)\n\nprint(housesales_gdf.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   propid   price  lnprice  advance  age  bathroom  bedroom buyage  centheat  \\\n0       1  105000       12    85000   18         1        2     25         1   \n1       2   84000       11    79800   31         1        1     47         0   \n2       3   89000       11    84550   16         1        1     30         0   \n3       4  136000       12   106000   31         2        4     32         2   \n4       5  103550       12    88000   31         1        2     38         1   \n\n   chelec  ...  psemi  pterrace  popdens  prkdouble  prknone  prksingle  \\\n0       0  ...      0         0        3          0        0          0   \n1       0  ...      0         0        0          0        0          0   \n2       0  ...      0         1       23          0        1          0   \n3       1  ...      0         1       23          0        1          0   \n4       0  ...      0         0       39          0        0          1   \n\n   prkspace  tenfree  tenlease                       geometry  \n0         1        0         1  POINT (504998.000 188930.000)  \n1         1        0         1  POINT (505026.000 177041.000)  \n2         0        1         0  POINT (505049.000 189030.000)  \n3         0        1         0  POINT (505087.000 189238.000)  \n4         0        0         1  POINT (505132.000 183300.000)  \n\n[5 rows x 34 columns]\n```\n:::\n:::\n\n\n### Zooming in or out\n\nIt's important to know what CRS your data is in if you want to create zoomed versions of your maps. [BBox finder](http://bboxfinder.com/#0.000000,0.000000,0.000000,0.000000) is a useful tool to identify coordinates in `EPSG:4326`.\n\nHere for example we are zooming in to some of the point we created at the beginning of the lab.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Create a plot\nfig, ax = plt.subplots(figsize=(10, 10))\n# Plot the districts\ndistricts_4326.plot(ax=ax, color='none', edgecolor='black')\n# Plot the points of interest\npoi_gdf.plot(ax=ax, color='blue', markersize=50)\n# Set the coordinate limits\nax.set_xlim(-0.180723, -0.014212)\nax.set_ylim(51.476668, 51.532337)\n# Remove axis labels and ticks\nax.set_axis_off()\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-22-output-1.png){width=763 height=419}\n:::\n:::\n\n\n## Manipulating Spatial Tables\n\nOnce we have an understanding of how to visually display spatial information contained, let us see how it can be combined with the operations related to manipulating non-spatial tabular data. Essentially, the key is to realize that a `GeoDataFrame` contain most of its spatial information in a single column named geometry, but the rest of it looks and behaves exactly like a non-spatial `DataFrame` (in fact, it is). This concedes them all the flexibility and convenience that we saw in manipulating, slicing, and transforming tabular data, with the bonus that spatial data is carried away in all those steps. In addition, `GeoDataFrame` also incorporate a set of explicitly spatial operations to combine and transform data. In this section, we will consider both.\n\n`GeoDataFrames` come with a whole range of traditional GIS operations built-in. Here we will run through a small subset of them that contains some of the most commonly used ones.\n\n::: {.panel-tabset group=\"data\"}\n\n## Area\n\nOne of the spatial aspects we often need from polygons is their area. \"How big is it?\" is a question that always haunts us when we think of countries, regions, or cities. To obtain area measurements, first make sure the `GeoDataFrame` you are working with is projected. If that is the case, you can calculate areas as follows:\n\nWe had already checked that district was projected to the British National Grid\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndistricts_areas = districts.area\ndistricts_areas.head()\n\nareas_in_sqkm = districts_areas / 1000000 #convert into squared kilometres\nareas_in_sqkm.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n0     3.151465\n1    37.778900\n2    86.736434\n3    64.263476\n4    43.235288\ndtype: float64\n```\n:::\n:::\n\n\n## Length\n\nSimilarly, an equally common question with lines is their length. Also similarly, their computation is relatively straightforward, provided that our data are projected.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nstreet_length = a_roads.length\nstreet_length.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n0       7.695310\n1     374.714434\n2     417.493662\n3      45.221697\n4    1748.445461\ndtype: float64\n```\n:::\n:::\n\n\nIf you check the `dataframe` you will see the lengths.\n\n## Centroids\n\nSometimes it is useful to summarize a polygon into a single point and, for that, a good candidate is its centroid (almost like a spatial analogue of the average).\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Create a dataframe with centroids\ncents = districts.centroid\ncents.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n0    POINT (532464.075 181219.688)\n1    POINT (548021.148 184939.599)\n2    POINT (524027.452 192316.258)\n3    POINT (548927.608 175720.862)\n4    POINT (520176.906 185829.122)\ndtype: geometry\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Create a plot\nfig, ax = plt.subplots(figsize=(10, 10))\n# Plot the districts\ndistricts.plot(ax=ax, color='lightgrey', edgecolor='black')\n# Plot the centroids\ncents.plot(ax=ax, color='red', markersize=10, edgecolor='none')\n# Set minimal theme by removing axes and grid\nax.set_axis_off()\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-26-output-1.png){width=763 height=594}\n:::\n:::\n\n\n## Buffers and selecting by location\n\nTo create a buffer using `geopandas`, simply call the buffer method, passing in the radious. For example, to draw a 1000m. buffer around every centroid of every district:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# buffer\nbuf = cents.buffer(1000)\nbuf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n0    POLYGON ((533464.075 181219.688, 533459.260 18...\n1    POLYGON ((549021.148 184939.599, 549016.333 18...\n2    POLYGON ((525027.452 192316.258, 525022.637 19...\n3    POLYGON ((549927.608 175720.862, 549922.793 17...\n4    POLYGON ((521176.906 185829.122, 521172.091 18...\ndtype: geometry\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Create a plot\nfig, ax = plt.subplots(figsize=(10, 10))\n# Plot the districts\ndistricts.plot(ax=ax, color='none', edgecolor='black')\n# Plot the centroids\ncents.plot(ax=ax, color='black', markersize=20, edgecolor='none')\n# Plot the centroid buffers\nbuf.plot(ax=ax, color='none', alpha=0.5, edgecolor='red')\n# Set minimal theme by removing axes and grid\nax.set_axis_off()\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-28-output-1.png){width=763 height=594}\n:::\n:::\n\n\n:::\n\n## Joins\n\n## Join districts with educational level data\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Import qualifications data from CSV\nqualifications2001_df = pd.read_csv(\"data/London/Tables/qualifications2001_2.csv\")\n\n# Take a quick look at the table by reading the first 5 lines\nqualifications2001_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Zone_Code</th>\n      <th>Zone_Name</th>\n      <th>Population1674</th>\n      <th>Noquals</th>\n      <th>Level1</th>\n      <th>Level2</th>\n      <th>Level3</th>\n      <th>Level4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>00AA</td>\n      <td>City of London</td>\n      <td>6067</td>\n      <td>607</td>\n      <td>359</td>\n      <td>634</td>\n      <td>665</td>\n      <td>3647</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>00AB</td>\n      <td>Barking and Dagenham</td>\n      <td>113579</td>\n      <td>44873</td>\n      <td>21654</td>\n      <td>20564</td>\n      <td>6626</td>\n      <td>11615</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>00AC</td>\n      <td>Barnet</td>\n      <td>228123</td>\n      <td>44806</td>\n      <td>25558</td>\n      <td>41118</td>\n      <td>24695</td>\n      <td>80907</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>00AD</td>\n      <td>Bexley</td>\n      <td>156172</td>\n      <td>44887</td>\n      <td>32110</td>\n      <td>35312</td>\n      <td>10759</td>\n      <td>20704</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>00AE</td>\n      <td>Brent</td>\n      <td>198712</td>\n      <td>48915</td>\n      <td>23913</td>\n      <td>33280</td>\n      <td>21121</td>\n      <td>60432</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nCheck the data\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Join check that the code you are joining the data on is the same.\n# First check the GeoDataFrame\ndistricts.head()\n\n# Then the DataFrame\nqualifications2001_df.head()\n\n## rename(columns={'Zone-Code': 'Dist_code'}) specifies that the column name Zone-Code should be renamed to Dist_code\nqualifications2001_df.rename(columns={'Zone_Code': 'DIST_CODE'}, inplace=True)\n```\n:::\n\n\nMerge the qualification dataset to the districts `GeoDataFrame`:\n\n- Merge the `qualifications2001_df` DataFrame with the `districts` `GeoDataFrame`.\n- The merge is done on the `DIST_CODE` column, which must be present in both DataFrames.\n- By default, this performs an inner join, but you can specify different types of joins (e.g., left, right) with the 'how' parameter.\n- `gpd.GeoDataFrame(...)` converts the resulting merged DataFrame into a GeoDataFrame using the 'geopandas' library.\n- `district_qual` is the new `GeoDataFrame` that contains the combined data from 'qualifications2001_df' and 'districts'.\n- `districts.plot()` plots the `GeoDataFrame` and `column='level 4'` specifies the column to plot.\n- `legend=True` adds a legend to the plot and `cmap='OrRd'` applies a color map.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndistrict_qual = districts.merge(qualifications2001_df, on='DIST_CODE')\n# Prove it worked\ndistrict_qual.plot(column=\"Level4\", cmap=\"OrRd\")\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-31-output-1.png){width=558 height=411}\n:::\n:::\n\n\n### Calculation\n\nNow, let's create the share of people with level 4 qualification, i.e. create the new variable `Level4p` equal to the number of people with level4 qualification divided by total population:\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# Assuming 'Level4' and 'Pop' columns exist in the merged GeoDataFrame district_qual\ndistrict_qual['Level4p'] = district_qual['Level4'] / district_qual['Population1674']\n```\n:::\n\n\n## Saving maps to figures\n\nCreate a file to put your maps:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Create directory \"maps\" if it doesn't exist\nos.makedirs(\"maps2\", exist_ok=True)\n```\n:::\n\n\nLet's create a simple map with the variable we just created and save to external file:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# Create a figure and axes for the plot\nfig, ax = plt.subplots()\n# Plot the districts' geometry with no fill color and black edges\ndistricts.plot(ax=ax, color='none', edgecolor='black')\n# Plot the district qualifications with a color map\ndistrict_qual.plot(ax=ax, column=\"Level4\", cmap=\"OrRd\", legend=True)\n# Save the plot to a PDF file\nplt.savefig(\"maps/london_test2.pdf\")\n# Save the plot as a JPG file\nplt.savefig(\"maps/london_test2.jpg\", format='jpg', dpi=300)\n# Close the plot\nplt.close()\n```\n:::\n\n\n## Adding baselayers\n\nMany single datasets lack context when displayed on their own. A common approach to alleviate this is to use web tiles, which are a way of quickly obtaining geographical context to present spatial data. In Python, we can use `contextily` to pull down tiles and display them along with our own geographic data.\n\nWe can begin by creating a map in the same way we would do normally, and then use the `add_basemap` command to add a basemap:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nax = restaurants.plot(color=\"black\")\ncx.add_basemap(ax, crs=restaurants.crs);\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-35-output-1.png){width=588 height=303}\n:::\n:::\n\n\nNote that we need to be explicit when adding the basemap to state the coordinate reference system (crs) our data is expressed in, `contextily` will not be able to pick it up otherwise. Conversely, we could change our data’s CRS into `Pseudo-Mercator`, the native reference system for most web tiles:\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nrestaurants_wm = restaurants.to_crs(epsg=3857)\nax = restaurants_wm.plot(color=\"black\")\ncx.add_basemap(ax);\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-36-output-1.png){width=522 height=425}\n:::\n:::\n\n\nNote how the coordinates are different but, if we set it right, either approach aligns tiles and data nicely.\n\nNow, contextily offers a lot of options in terms of the sources and providers you can use to create your basemaps. For example, we can use satellite imagery instead. A lot more about basemap options with `contextly` [here](https://contextily.readthedocs.io/en/latest/providers_deepdive.html).\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nf, ax = plt.subplots(1, figsize=(9, 9))\ndistricts.plot(alpha=0.5, ax=ax)\ncx.add_basemap(\n    ax, \n    crs=districts.crs,\n    source=cx.providers.Esri.WorldImagery\n)\nax.set_axis_off()\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](spatialdataPy_files/figure-html/cell-37-output-1.png){width=689 height=536}\n:::\n:::\n\n\n## Interactive maps\n\n",
    "supporting": [
      "spatialdataPy_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}