{
  "hash": "cb02fa06191a8e5aad38ead6fcea09b2",
  "result": {
    "engine": "jupyter",
    "markdown": "# Lab in Python {#sec-map-raster-Python .unnumbered}\n\nIn this session, we will further explore the world of geographic data visualization by building upon our understanding of both raster data and choropleths. Raster data, consisting of gridded cells, allows us to represent continuous geographic phenomena such as temperature, elevation, or satellite imagery. Choropleths, on the other hand, are an effective way to visualize spatial patterns through the use of color-coded regions, making them invaluable for displaying discrete data like population density or election results. By combining these techniques, we will gain a comprehensive toolkit for conveying complex geographical information in a visually compelling manner.\n\n## Importing Modules\n\n::: {#5c0387c1 .cell execution_count=1}\n``` {.python .cell-code}\n# Raster modules for python\nimport rasterio\nfrom rasterio.warp import reproject, Resampling, calculate_default_transform\nfrom rasterio.mask import mask\nfrom rasterio.plot import show\n\nfrom shapely.geometry import mapping\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib.colorbar as colorbar\nimport geopandas as gpd\n```\n:::\n\n\n## Terrain data\n\n### **Import raster data**\n\nRaster **terrain** data consists of gridded elevation values that represent the topography of a geographic area. You can download this from the [relevant github folder](https://github.com/pietrostefani/gds/tree/main/data/Lebanon). A good place to download elevation data is [Earth Explorer](https://earthexplorer.usgs.gov/). This [video](https://www.youtube.com/watch?v=NQg0g9ObhXE) takes you through the download process if you want to try this out yourself.\n\nWe first import a raster file for elevation.\n\n::: {#1931e583 .cell execution_count=2}\n``` {.python .cell-code}\n# Load the raster data\nelevation = rasterio.open(\"data/Lebanon/LBN_elevation_w_bathymetry.tif\")\n```\n:::\n\n\nPlot it.\n\n::: {#437a9ccf .cell execution_count=3}\n``` {.python .cell-code}\nplt.figure(figsize=(10, 8))\nplt.imshow(elevation.read(1), cmap='viridis')\nplt.colorbar(label='Elevation')\nplt.title('Elevation with Bathymetry')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](maprasterPy_files/figure-html/cell-4-output-1.png){width=788 height=611}\n:::\n:::\n\n\nThis information is typically accessed and updated via the .profile.\n\n::: {#71529f75 .cell execution_count=4}\n``` {.python .cell-code}\nprint(elevation.profile)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'driver': 'GTiff', 'dtype': 'float64', 'nodata': nan, 'width': 1150, 'height': 708, 'count': 1, 'crs': CRS.from_epsg(4326), 'transform': Affine(0.002500000000000124, 0.0, 33.74907268219525,\n       0.0, -0.002500000000000124, 34.833268747734884), 'blockxsize': 256, 'blockysize': 256, 'tiled': True, 'compress': 'deflate', 'interleave': 'band'}\n```\n:::\n:::\n\n\nHave a look at the CRS.\n\n::: {#b5df15f6 .cell execution_count=5}\n``` {.python .cell-code}\n# Check the CRS of the raster\ncrs = elevation.crs\nprint(crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEPSG:4326\n```\n:::\n:::\n\n\n### **Import the Lebanon shapefile**\n\nImport the Lebanon shapefile, plot it, and verify its Coordinate Reference System (CRS). Is it the same as the raster's CRS?\n\n::: {#5cabb155 .cell execution_count=6}\n``` {.python .cell-code}\n# Load the shapefile data\nLebanon_adm1 = gpd.read_file(\"data/Lebanon/LBN_adm1.shp\")\n\n# Plot the geometry\nLebanon_adm1.plot(edgecolor='grey', facecolor='none')\nplt.title('Lebanon Administrative Boundaries')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](maprasterPy_files/figure-html/cell-7-output-1.png){width=375 height=431}\n:::\n:::\n\n\n::: {#1f606762 .cell execution_count=7}\n``` {.python .cell-code}\n# Check the CRS of the shapefile\ncrs = Lebanon_adm1.crs\nprint(crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEPSG:22770\n```\n:::\n:::\n\n\n### **Reproject the Raster**\n\n::: {#b2ef627c .cell execution_count=8}\n``` {.python .cell-code}\n# Define the desired destination CRS\ndst_crs = \"EPSG:22770\"  # For example, WGS84\n\n# Calculate the transform matrix, width, and height for the output raster\ndst_transform, width, height = calculate_default_transform(\n    elevation.crs,  # source CRS from the raster\n    dst_crs,        # destination CRS\n    elevation.width,  # column count\n    elevation.height, # row count\n    *elevation.bounds  # outer boundaries (left, bottom, right, top)\n)\n\n# Print the source and destination transforms\nprint(\"Source Transform:\\n\", elevation.transform, '\\n')\nprint(\"Destination Transform:\\n\", dst_transform)\n\n# Define the metadata for the output raster\ndst_meta = elevation.meta.copy()\ndst_meta.update({\n    'crs': dst_crs,\n    'transform': dst_transform,\n    'width': width,\n    'height': height\n})\n\n# Reproject and write the output raster\nwith rasterio.open(\"data/Lebanon/reprojected_elevation.tif\", \"w\", **dst_meta) as dst:\n    for i in range(1, elevation.count + 1):\n        reproject(\n            source=rasterio.band(elevation, i),\n            destination=rasterio.band(dst, i),\n            src_transform=elevation.transform,\n            src_crs=elevation.crs,\n            dst_transform=dst_transform,\n            dst_crs=dst_crs,\n            resampling=Resampling.nearest\n        )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSource Transform:\n | 0.00, 0.00, 33.75|\n| 0.00,-0.00, 34.83|\n| 0.00, 0.00, 1.00| \n\nDestination Transform:\n | 244.50, 0.00,-36219.30|\n| 0.00,-244.50, 326205.11|\n| 0.00, 0.00, 1.00|\n```\n:::\n:::\n\n\n### **Cropping and Masking**\n\n**Cropping**:\n\n-   Purpose: Cropping a raster involves changing the extent of the raster dataset by specifying a new bounding box or geographic area of interest. The result is a new raster that covers only the specified region.\n\n-   Typical Use: Cropping is commonly used when you want to reduce the size of a raster dataset to focus on a smaller geographic area of interest while retaining all the original data values within that area.\n\n**Masking**:\n\n-   Purpose: Applying a binary mask to the dataset. The mask is typically a separate raster or polygon layer where certain areas are designated as \"masked\" (1) or \"unmasked\" (0).\n\n-   Typical Use: Masking is used when you want to extract or isolate specific areas or features within a raster dataset. For example, you might use a mask to extract land cover information within the boundaries of a protected national park.\n\nIn many cases, these cropping and masking are executed one after the other because it is computationally easier to crop when dealing with large datasets, and then masking.\n\n::: {#7a584972 .cell execution_count=9}\n``` {.python .cell-code}\nelevation_22770 = rasterio.open(\"data/Lebanon/reprojected_elevation.tif\")\n\n# Use unary_union method to combine the geometries\nlebanon_union = Lebanon_adm1.geometry.unary_union\n\n# Crop the elevation data to the extent of Lebanon\nelevation_lebanon, elevation_lebanon_transform = mask(elevation_22770, [mapping(lebanon_union)], crop=True)\n```\n:::\n\n\n### **Plot elevation**\n\n::: {#cd734af8 .cell execution_count=10}\n``` {.python .cell-code}\n# Assuming elevation_lebanon contains the cropped elevation data and Lebanon_adm1 is the GeoDataFrame\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Plot the elevation data\nshow(elevation_lebanon, transform=elevation_lebanon_transform, ax=ax, cmap='terrain')\n\n# Plot the Lebanon boundaries on top, with no fill color\nLebanon_adm1.boundary.plot(ax=ax, edgecolor='black')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](maprasterPy_files/figure-html/cell-11-output-1.png){width=719 height=781}\n:::\n:::\n\n\nLet's improve this a bit. Remember that there is a lot we can do with [Cmap](https://www.analyticsvidhya.com/blog/2020/09/colormaps-matplotlib/#:~:text=Colormaps%20or%20Cmap%20in%20python%20colormaps%20is%20a%20very%20useful,custom%20ones%20using%20python%20colormaps).\n\n...\n\nQuestions to ask yourself about how you can improve these maps, going back to [geo-visualisation and choropleths](https://pietrostefani.github.io/gds/mapvector.html).\n\n-   What are the logical breaks for elevation data?\n\n-   Should the colours be changed to standard elevation pallettes?\n\n### **Slope**\n\nWe are now going to calculate slopes\n\n### **Flood risk area**\n\nWe can employ reclassification techniques to delineate flood risk areas. Specifically, we identify and classify areas where the elevation is under 10 meters above sea level as high-risk zones. This critical step in flood risk assessment helps communities and decision-makers pinpoint vulnerable areas, enabling them to implement effective mitigation strategies and disaster preparedness plans to safeguard against potential flooding events.\n\n### **Spatial join with vector data**\n\nYou might want to extract values from a raster data set, and then map them within a vector framework or extract them to analyse them statistically. If it therefore very useful to know how to extract:\n\n::: callout-important\nMake sure all your data is in the same CRS, otherwise the ... function will not work properly.\n\n\n:::\n\n## Night Lights\n\nThis section is a bit more advanced, there are hints along the way to make it simpler.\n\n### **Download data**\n\n::: {.callout-note title=\"Download the Data\"}\n\nWe need to download some raster data. NOAA has made nighttime lights data available for 1992 to 2013. It is called the Version 4 DMSP-OLS Nighttime Lights Time Series. The files are cloud-free composites made using all the available archived DMSP-OLS smooth resolution data for calendar years. In cases where two satellites were collecting data - two composites were produced. The products are 30 arc-second grids, spanning -180 to 180 degrees longitude and -65 to 75 degrees latitude. We can download the [Average, Visible, Stable Lights, & Cloud Free Coverages for 1992 and 2013](https://www.ngdc.noaa.gov/eog/data/web_data/v4composites/) and put them in the `data/Kenya_Tanzania` folder.\n\n::: \n\n::: callout-important\nYou can also download the data [here](https://theuniversityofliverpool-my.sharepoint.com/:u:/g/personal/pietrost_liverpool_ac_uk/EX85foAh7ZBBtSZ64pxbFmsBStf8UX2uaLXE5MBYJt6PeQ?e=LMYu7d). You will need to be logged into your UoL account.\n\nThe downloaded files are going to be in a **\"TAR\" format**. A TAR file is an archive created by tar, a Unix-based utility used to package files together for backup or distribution purposes. It contains multiple files stored in an uncompressed format along with metadata about the archive. Tars files are also used to reduce files' size. TAR archives compressed with GNU Zip compression may become GZ, .TAR.GZ, or .TGZ files. We need to decompress them before using them.\n:::\n\nBefore you move forward **download the data for 1992 and 2013.** It is also good practice to create a scratch folder where you do all your unzipping.\n\n## Resources\n\n-   [Python Open Source Spatial Programming & Remote Sensing](https://pygis.io/docs/e_interpolation.html)\n\n",
    "supporting": [
      "maprasterPy_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}