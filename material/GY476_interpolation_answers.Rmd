---
title: "GY476_Interpolation_Point_Patterns"
author: "Louise Bernard & Elisabetta Pietrostefani" 
date: "updated 26/10/2021"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 2
---

# Install all relevant packages

* gstat: Spatial and Spatio-Temporal Geostatistical Modelling, Prediction and Simulation
* spdep: Spatial Dependence: Weighting Schemes, Statistics. 

```{r setup, include=FALSE, echo=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!require("gstat")) install.packages("gstat") #https://cran.r-project.org/web/packages/gstat/index.html
if(!require("raster")) install.packages("raster")
if(!require("sf")) install.packages("sf")
if(!require("dplyr")) install.packages("dplyr")
if(!require("spdep")) install.packages("spdep")
if(!require("tmap")) install.packages("tmap")
if(!require("spatstat")) install.packages("spatstat")
if(!require("mapview")) install.packages("mapview")


```

# Relative and absolute path

``` {r setdatafolder}

getwd() # check working directory
datafolder <- file.path("../GY476_data_2022_23") # define the location of the data folder
```

# Interpolation - Buen Aires Airbnb data

**Task 3:** Repeat **Interpolation** exercise  with Buenos Aires  data

Hints: 

* Load the neighbourhood shapefile and check the CRS
* Load the clean listings (without outliers), find the coordinates, set the default CRS and re-project it to be able to calculate the distance
* Adjust the number of neighbours and power to get a nice smooth predicted for BA

``` {r set up}
# import Buenos Aires polygons
BA <- read_sf(file.path(datafolder, "InsideAirbnb/neighbourhoods_BA_posgar.shp"))

# read the AirBnb listing
listings <- read.csv(file.path(datafolder, "InsideAirbnb/listings_nooutliers.csv"))
summary(listings)

# locate the longitude and latitude
names(listings)

# create a sf object
listings <- st_as_sf(listings, coords = c(8, 7)) # create pts from coordinates
# set the CRS as WGS 84
listings <-  st_set_crs(listings, 4326) # set crs
# Transform it to Buenos Aires projected coordinates
listings <- st_transform(listings, st_crs(BA))

# plot
plot(BA$geometry)
plot(listings$geometry, add=TRUE)

```

* Note that you could alternatively read the shapefile of the listings, not the csv.
In which case the process might be slightly different.

``` {r krig}

# Create geostatistical prediction using a ordinary Kriging
gs <- gstat(formula = price~1, # formula that defines the dependent variable as a linear model of independent variables
            data = listings, # housesales data 
            nmax = 500, # the number of nearest observations that should be used
            set=list(idp = 0.2)) # set inverse distance power  

# Create a blank raster using district extent and crs
r <- raster(BA, resolution=200) # output cell size 

# Create the interpolated raster using the prediction from the model and the blank raster
idw <- interpolate(r, gs)

# Mask values outside London
idwr <- mask(idw, BA)

# Plot result
plot(idwr, col = rev(heat.colors(100)))
plot(BA$geometry, fill = NA, add=T)

```

* Note that this is an example and you can, as done in class, play around with
1. number of nearest observations
2. inverse distance power
3. output cell size 250
and decide how to best interpolate your data

# Point Patterns - Buen Aires Airbnb data

Getting data into spatstat format

* These tools are designed to work with points stored as ppp objects and not SpatialPointsDataFrame or sf objects
* Note that a ppp object may or may not have attribute information (also referred to as marks).
* We will only concern ourselves with the pattern generated by the points and not their attributes

```{r prepare data}
# Load polygon neighbourhoods
BA <- read_sf(file.path(datafolder, "InsideAirbnb", "neighbourhoods_BA_posgar.shp"))
BA_owin  <- as.owin(BA)
BA_owin <- rescale(BA_owin, 1000)
 
# load point feature shapefile
listings <- read_sf(file.path(datafolder, "InsideAirbnb", "listings_BA_posgar.shp"))
listings_ppp  <- as.ppp(listings) # We can create a `ppp` object, object needs to be projected
marks(listings_ppp) <- NULL #remove all marks from point object
listings_ppp <- rescale(listings_ppp, 1000)

Window(listings_ppp) <- BA_owin # Creating window. Many point pattern analyses such as the average nearest neighbor analysis should have their study boundaries explicitly defined. This can be done in spatstat by “binding” the extent polygon to the  point feature object using the Window() function.
```

Plot ppp 
```{r plot point layer}
plot(listings_ppp, main=NULL, cols=rgb(0,0,0,.2), pch=20)
```

If we create an interactive plot for this dataset with `mapview`, using
```{r map2}
library(mapview)
mapviewOptions(fgb = FALSE) # not needed locally
mapview(listings)
```
we can zoom and click on points to see their attributes.

Sheather & Jones (1991) to select the bandwidth using pilot estimation of derivatives
```{r 2}
plot(density(listings_ppp, bw = "SJ")) #bw - Alternative to sigma for consistency with other functions
plot(BA_owin, add = TRUE)
```

Of course, this density depends on the bandwidth, and we can create more
rough or smooth versions by setting it
```{r}
plot(density(listings_ppp, sigma = 1e6))
plot(BA_owin, add = TRUE)
```

Or automatic bandwidth selection
```{r}
plot(density(listings_ppp,sigma=bw.diggle(cells)))
plot(BA_owin, add = TRUE)
```

Or different Kernel
```{r}
plot(density(listings_ppp, sigma=0.4, kernel="epanechnikov"))
plot(BA_owin, add = TRUE)
```

Or we can do Quadrat density
```{r 3}
Q <- quadratcount(listings_ppp, nx= 6, ny=3)
plot(listings_ppp, pch=20, cols="grey70", main=NULL)  # Plot points
plot(Q, add=TRUE)  # Add quadrat grid

# Compute the density for each quadrat
Q.d <- intensity(Q)

# Plot the density
plot(intensity(Q, image=TRUE), main=NULL, las=1)  # Plot density raster
plot(listings_ppp, pch=20, cex=0.6, col=rgb(0,0,0,.5), add=TRUE)  # Add points
``` 

#References

https://keen-swartz-3146c4.netlify.app/pointpatterns.html